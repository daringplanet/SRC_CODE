; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30723.0 

	TITLE	V:\CompOrgProject\EncryptData_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?encryptData@@YAHPADH@Z				; encryptData
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?gkey@@3PAEA:BYTE				; gkey
EXTRN	?gptrKey@@3PAEA:DWORD				; gptrKey
EXTRN	?gPassword@@3PADA:BYTE				; gPassword
EXTRN	?gPasswordHash@@3PAEA:BYTE			; gPasswordHash
EXTRN	?gptrPasswordHash@@3PAEA:DWORD			; gptrPasswordHash
EXTRN	?gdebug1@@3EA:BYTE				; gdebug1
EXTRN	?gdebug2@@3EA:BYTE				; gdebug2
EXTRN	?gNumRounds@@3HA:DWORD				; gNumRounds
EXTRN	?gEncodeTable@@3PAEA:BYTE			; gEncodeTable
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File v:\comporgproject\encryptdata_initial.cpp
;	COMDAT ?encryptData@@YAHPADH@Z
_TEXT	SEGMENT
_resulti$ = -8						; size = 4
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
?encryptData@@YAHPADH@Z PROC				; encryptData, COMDAT

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 12   : 
; 13   : 
; 14   : 
; 15   : 
; 16   : 
; 17   : 
; 18   : 
; 19   : 
; 20   : 
; 21   : 
; 22   : 	int resulti = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _resulti$[ebp], 0

; 23   : 
; 24   : 	gdebug1 = 0;					// a couple of global variables that could be used for debugging

  00025	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug1@@3EA, 0 ; gdebug1

; 25   : 	gdebug2 = 0;					// also can have a breakpoint in C code

  0002c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug2@@3EA, 0 ; gdebug2

; 26   : 
; 27   : 
; 28   : 
; 29   : 
; 30   : 
; 31   : 
; 32   : 	// You can not declare any local variables in C, but should use resulti to indicate any errors
; 33   : 	// Set up the stack frame and assign variables in assembly if you need to do so
; 34   : 	// access the parameters BEFORE setting up your own stack frame
; 35   : 	// Also, you cannot use a lot of global variables - work with registers
; 36   : 
; 37   : 	__asm {
; 38   : 	
; 39   : 		
; 40   : 		//clearing ecx to create a counter
; 41   : 			xor ecx, ecx

  00033	33 c9		 xor	 ecx, ecx
$START$3:

; 42   : 
; 43   : START :
; 44   : 
; 45   : 			mov ebx, dataLength  //putting the lenght of the data in edx

  00035	8b 5d 0c	 mov	 ebx, DWORD PTR _dataLength$[ebp]

; 46   : 			lea edi, gkey   //putting the starting value of gkey into edi

  00038	8d 3d 00 00 00
	00		 lea	 edi, OFFSET ?gkey@@3PAEA

; 47   : 			lea esi, gPasswordHash //putting the starting value of gPasswordHash into esi

  0003e	8d 35 00 00 00
	00		 lea	 esi, OFFSET ?gPasswordHash@@3PAEA

; 48   : 
; 49   : 
; 50   : 
; 51   : 			//preserves the number of rounds
; 52   : 			push ecx

  00044	51		 push	 ecx

; 53   : 			
; 54   : 			mov edx, data //gets data

  00045	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]

; 55   : 			mov ebx, edx  //moves data into ebx

  00048	8b da		 mov	 ebx, edx

; 56   : 			add ebx, dataLength

  0004a	03 5d 0c	 add	 ebx, DWORD PTR _dataLength$[ebp]

; 57   : 			//setting up the hop count
; 58   : 			xor eax, eax   

  0004d	33 c0		 xor	 eax, eax

; 59   : 			mov ah, byte ptr[esi + 2 + ecx * 4] //

  0004f	8a 64 8e 02	 mov	 ah, BYTE PTR [esi+ecx*4+2]

; 60   : 			mov al, byte ptr[esi + 3 + ecx * 4]

  00053	8a 44 8e 03	 mov	 al, BYTE PTR [esi+ecx*4+3]

; 61   : 			cmp ax, 0

  00057	66 83 f8 00	 cmp	 ax, 0

; 62   : 			je NEWHOP

  0005b	0f 84 ea 00 00
	00		 je	 $NEWHOP$4

; 63   : 			mov resulti, eax

  00061	89 45 f8	 mov	 DWORD PTR _resulti$[ebp], eax
$CN$5:

; 64   : CN:	//getting the index
; 65   : 			xor eax, eax		

  00064	33 c0		 xor	 eax, eax

; 66   : 			mov ah, byte ptr[esi + ecx*4]

  00066	8a 24 8e	 mov	 ah, BYTE PTR [esi+ecx*4]

; 67   : 			mov al, byte ptr[esi + ecx*4 + 1]

  00069	8a 44 8e 01	 mov	 al, BYTE PTR [esi+ecx*4+1]
$NEXT$6:

; 68   : 			
; 69   : 		
; 70   : 		
; 71   : 	
; 72   : 
; 73   : NEXT:  //Encyrpting the data with the hash
; 74   : 			xor ecx, ecx

  0006d	33 c9		 xor	 ecx, ecx

; 75   : 			mov cl, byte ptr[edx]

  0006f	8a 0a		 mov	 cl, BYTE PTR [edx]

; 76   : 			xor cl, byte ptr[edi + eax]

  00071	32 0c 07	 xor	 cl, BYTE PTR [edi+eax]

; 77   : 			mov byte ptr[edx], cl

  00074	88 0a		 mov	 BYTE PTR [edx], cl

; 78   : 
; 79   : 			inc edx

  00076	42		 inc	 edx

; 80   : 			cmp edx, ebx  //checks to see if we're done encrypting data

  00077	3b d3		 cmp	 edx, ebx

; 81   : 			je EDONE

  00079	74 11		 je	 SHORT $EDONE$7

; 82   : 			
; 83   : 			add eax, resulti  //update by the hop count

  0007b	03 45 f8	 add	 eax, DWORD PTR _resulti$[ebp]

; 84   : 			cmp eax, 65537  //check boundary conditions

  0007e	3d 01 00 01 00	 cmp	 eax, 65537		; 00010001H

; 85   : 			jb NEXT //repeat until done 

  00083	72 e8		 jb	 SHORT $NEXT$6

; 86   : 			sub eax, 65537

  00085	2d 01 00 01 00	 sub	 eax, 65537		; 00010001H

; 87   : 			jmp NEXT

  0008a	eb e1		 jmp	 SHORT $NEXT$6
$EDONE$7:

; 88   : 
; 89   : 
; 90   : 
; 91   : 		EDONE :
; 92   : 
; 93   : 		
; 94   : 			//setting up for bit manipulation(DACBE)
; 95   : 			mov ebx, dataLength

  0008c	8b 5d 0c	 mov	 ebx, DWORD PTR _dataLength$[ebp]

; 96   : 			lea esi, gkey

  0008f	8d 35 00 00 00
	00		 lea	 esi, OFFSET ?gkey@@3PAEA

; 97   : 			mov esi, gptrKey

  00095	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gptrKey@@3PAEA ; gptrKey

; 98   : 			lea esi, gPassword

  0009b	8d 35 00 00 00
	00		 lea	 esi, OFFSET ?gPassword@@3PADA

; 99   : 			mov esi, gptrPasswordHash

  000a1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gptrPasswordHash@@3PAEA ; gptrPasswordHash

; 100  : 
; 101  : 
; 102  : 			//clearing the counter
; 103  : 			xor ecx, ecx

  000a7	33 c9		 xor	 ecx, ecx

; 104  : 			mov edi, data

  000a9	8b 7d 08	 mov	 edi, DWORD PTR _data$[ebp]
$START2$8:

; 105  : 
; 106  : 
; 107  : 		START2 :
; 108  : 			//checking to see if we're at the end of the data
; 109  : 		cmp ecx, dataLength

  000ac	3b 4d 0c	 cmp	 ecx, DWORD PTR _dataLength$[ebp]

; 110  : 			jge DONE

  000af	0f 8d a5 00 00
	00		 jge	 $DONE$9
$D$10:

; 111  : 
; 112  : 
; 113  : 
; 114  : 		D :
; 115  : 		//rotating high nibble left and low nibble right
; 116  : 		xor edx, edx

  000b5	33 d2		 xor	 edx, edx

; 117  : 			xor ebx, ebx

  000b7	33 db		 xor	 ebx, ebx

; 118  : 			movzx eax, byte ptr[edi + ecx]

  000b9	0f b6 04 0f	 movzx	 eax, BYTE PTR [edi+ecx]

; 119  : 			mov dl, al //gets one byte of the data

  000bd	8a d0		 mov	 dl, al

; 120  : 			and dl, 0xf0 

  000bf	80 e2 f0	 and	 dl, -16			; fffffff0H

; 121  : 			clc

  000c2	f8		 clc

; 122  : 			rol dl, 1 //rotating the high nibble left 

  000c3	d0 c2		 rol	 dl, 1

; 123  : 			jc RH

  000c5	72 0c		 jb	 SHORT $RH$11
$RO1$12:

; 124  : 		RO1 :
; 125  : 
; 126  : 		mov bl, al

  000c7	8a d8		 mov	 bl, al

; 127  : 			and bl, 0x0f

  000c9	80 e3 0f	 and	 bl, 15			; 0000000fH

; 128  : 			clc

  000cc	f8		 clc

; 129  : 			ror bl, 1 //rotaing low nibble right

  000cd	d0 cb		 ror	 bl, 1

; 130  : 			jc RL

  000cf	72 0a		 jb	 SHORT $RL$13

; 131  : 			jmp DDONE

  000d1	eb 10		 jmp	 SHORT $DDONE$14
$RH$11:

; 132  : 
; 133  : 			//checking to see if there was an end bit that was rotated out 
; 134  : 		RH :
; 135  : 		and dl, 0xf0

  000d3	80 e2 f0	 and	 dl, -16			; fffffff0H

; 136  : 			or dl, 0x10

  000d6	80 ca 10	 or	 dl, 16			; 00000010H

; 137  : 			jmp RO1

  000d9	eb ec		 jmp	 SHORT $RO1$12
$RL$13:

; 138  : 
; 139  : 		RL :
; 140  : 		//also checking for end bit but on opposite side 
; 141  : 		and bl, 0x0f

  000db	80 e3 0f	 and	 bl, 15			; 0000000fH

; 142  : 			or bl, 0x08

  000de	80 cb 08	 or	 bl, 8

; 143  : 			jmp DDONE

  000e1	eb 00		 jmp	 SHORT $DDONE$14
$DDONE$14:

; 144  : 
; 145  : 		DDONE :
; 146  : 
; 147  : 		xor eax, eax

  000e3	33 c0		 xor	 eax, eax

; 148  : 			add eax, edx

  000e5	03 c2		 add	 eax, edx

; 149  : 			add eax, ebx

  000e7	03 c3		 add	 eax, ebx

; 150  : 			mov byte ptr[edi + ecx], al

  000e9	88 04 0f	 mov	 BYTE PTR [edi+ecx], al
$A$15:

; 151  : 
; 152  : 
; 153  : 		A :
; 154  : 		movzx eax, byte ptr[edi + ecx]

  000ec	0f b6 04 0f	 movzx	 eax, BYTE PTR [edi+ecx]

; 155  : 			rol al, 1 //rotating the bit to to the left 

  000f0	d0 c0		 rol	 al, 1

; 156  : 			mov byte ptr[edi + ecx], al

  000f2	88 04 0f	 mov	 BYTE PTR [edi+ecx], al
$C$16:

; 157  : 
; 158  : 
; 159  : 		C :
; 160  : 		//reversing the bit order
; 161  : 		movzx eax, byte ptr[edi + ecx]

  000f5	0f b6 04 0f	 movzx	 eax, BYTE PTR [edi+ecx]

; 162  : 			xor ebx, ebx

  000f9	33 db		 xor	 ebx, ebx

; 163  : 			xor edx, edx

  000fb	33 d2		 xor	 edx, edx

; 164  : 			//counter to move all the bits 
; 165  : 			mov edx, 7

  000fd	ba 07 00 00 00	 mov	 edx, 7
$LOOP1$17:

; 166  : 			//loop to rotate all bits until the order is reversed
; 167  : 		LOOP1:
; 168  : 		sal al, 1

  00102	d0 e0		 shl	 al, 1

; 169  : 			rcr bl, 1  //rotating a bit through the carry 

  00104	d0 db		 rcr	 bl, 1

; 170  : 			test edx, edx

  00106	85 d2		 test	 edx, edx

; 171  : 			je CDONE

  00108	74 03		 je	 SHORT $CDONE$18

; 172  : 			dec edx

  0010a	4a		 dec	 edx

; 173  : 			jmp LOOP1

  0010b	eb f5		 jmp	 SHORT $LOOP1$17
$CDONE$18:

; 174  : 
; 175  : 		CDONE :
; 176  : 		mov al, bl

  0010d	8a c3		 mov	 al, bl

; 177  : 			mov byte ptr[edi + ecx], al

  0010f	88 04 0f	 mov	 BYTE PTR [edi+ecx], al
$B$19:

; 178  : 
; 179  : 
; 180  : 
; 181  : 		B ://swapping nibbles
; 182  : 		xor edx, edx

  00112	33 d2		 xor	 edx, edx

; 183  : 			xor ebx, ebx

  00114	33 db		 xor	 ebx, ebx

; 184  : 			movzx eax, byte ptr[edi + ecx]

  00116	0f b6 04 0f	 movzx	 eax, BYTE PTR [edi+ecx]

; 185  : 			mov dl, al

  0011a	8a d0		 mov	 dl, al

; 186  : 			mov bl, al

  0011c	8a d8		 mov	 bl, al

; 187  : 
; 188  : 
; 189  : 
; 190  : 			and dl, 0xf0 //preserving one of the bits 

  0011e	80 e2 f0	 and	 dl, -16			; fffffff0H

; 191  : 			ror dl, 4  //rotating the bit to the right 4 times 

  00121	c0 ca 04	 ror	 dl, 4

; 192  : 
; 193  : 
; 194  : 			and bl, 0x0f //preserving the opposite bit

  00124	80 e3 0f	 and	 bl, 15			; 0000000fH

; 195  : 			ror bl, 4 //rotating it again 4 times 

  00127	c0 cb 04	 ror	 bl, 4

; 196  : 
; 197  : 
; 198  : 			xor eax, eax

  0012a	33 c0		 xor	 eax, eax

; 199  : 			add eax, ebx

  0012c	03 c3		 add	 eax, ebx

; 200  : 			add eax, edx

  0012e	03 c2		 add	 eax, edx

; 201  : 			mov byte ptr[edi + ecx], al

  00130	88 04 0f	 mov	 BYTE PTR [edi+ecx], al
$E$20:

; 202  : 
; 203  : 
; 204  : 		E :   //code table swap
; 205  : 
; 206  : 
; 207  : 
; 208  : 		movzx eax, byte ptr[edi + ecx]

  00133	0f b6 04 0f	 movzx	 eax, BYTE PTR [edi+ecx]

; 209  : 			lea esi, gEncodeTable //gets first value of the table

  00137	8d 35 00 00 00
	00		 lea	 esi, OFFSET ?gEncodeTable@@3PAEA

; 210  : 			movzx al, [esi + eax] //

  0013d	66 0f b6 04 06	 movzx	 ax, BYTE PTR [esi+eax]

; 211  : 			mov byte ptr[edi + ecx], al  //swap data with the new bit from ecnrytpion table 

  00142	88 04 0f	 mov	 BYTE PTR [edi+ecx], al

; 212  : 
; 213  : 
; 214  : 
; 215  : 
; 216  : 
; 217  : 
; 218  : 			inc ecx

  00145	41		 inc	 ecx

; 219  : 			jmp START2

  00146	e9 61 ff ff ff	 jmp	 $START2$8
$NEWHOP$4:

; 220  : 
; 221  : NEWHOP :  //if its 0 then sets the hop counts to FFFF
; 222  : 			xor eax, eax

  0014b	33 c0		 xor	 eax, eax

; 223  : 			mov eax, 0xffff

  0014d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 224  : 			mov resulti, eax

  00152	89 45 f8	 mov	 DWORD PTR _resulti$[ebp], eax

; 225  : 			jmp CN

  00155	e9 0a ff ff ff	 jmp	 $CN$5
$DONE$9:

; 226  : 
; 227  : 
; 228  : 		DONE :
; 229  : 			pop ecx

  0015a	59		 pop	 ecx

; 230  : 				inc ecx

  0015b	41		 inc	 ecx

; 231  : 				cmp ecx, gNumRounds

  0015c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gNumRounds@@3HA ; gNumRounds

; 232  : 				jne START

  00162	0f 85 cd fe ff
	ff		 jne	 $START$3

; 233  : 				mov resulti, 0

  00168	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _resulti$[ebp], 0

; 234  : 
; 235  : 	}
; 236  : 
; 237  : 	
; 238  : 
; 239  : 	return resulti;

  0016f	8b 45 f8	 mov	 eax, DWORD PTR _resulti$[ebp]

; 240  : } // encryptData

  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0017b	3b ec		 cmp	 ebp, esp
  0017d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
?encryptData@@YAHPADH@Z ENDP				; encryptData
_TEXT	ENDS
END
