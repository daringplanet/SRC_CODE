; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30723.0 

	TITLE	V:\CompOrgProject\DecryptData_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?decryptData@@YAHPADH@Z				; decryptData
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?gkey@@3PAEA:BYTE				; gkey
EXTRN	?gptrKey@@3PAEA:DWORD				; gptrKey
EXTRN	?gPasswordHash@@3PAEA:BYTE			; gPasswordHash
EXTRN	?gptrPasswordHash@@3PAEA:DWORD			; gptrPasswordHash
EXTRN	?gdebug1@@3EA:BYTE				; gdebug1
EXTRN	?gdebug2@@3EA:BYTE				; gdebug2
EXTRN	?gNumRounds@@3HA:DWORD				; gNumRounds
EXTRN	?gDecodeTable@@3PAEA:BYTE			; gDecodeTable
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File v:\comporgproject\decryptdata_initial.cpp
;	COMDAT ?decryptData@@YAHPADH@Z
_TEXT	SEGMENT
_resulti$ = -8						; size = 4
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
?decryptData@@YAHPADH@Z PROC				; decryptData, COMDAT

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 12   : 	int resulti = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _resulti$[ebp], 0

; 13   : 	
; 14   : 	
; 15   : 	gdebug1 = 0;					// a couple of global variables that could be used for debugging

  00025	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug1@@3EA, 0 ; gdebug1

; 16   : 	gdebug2 = 0;					// also can have a breakpoint in C code

  0002c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug2@@3EA, 0 ; gdebug2

; 17   : 
; 18   : 
; 19   : 	// Set up the stack frame and assign variables in assembly if you need to do so
; 20   : 	// access the parameters BEFORE setting up your own stack frame
; 21   : 	// Also, you cannot use a lot of global variables - work with registers
; 22   : 
; 23   : __asm {
; 24   : 		mov ecx, gNumRounds

  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gNumRounds@@3HA ; gNumRounds

; 25   : 			dec ecx

  00039	49		 dec	 ecx

; 26   : 			mov gNumRounds, ecx

  0003a	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gNumRounds@@3HA, ecx ; gNumRounds
$START2$3:

; 27   : 
; 28   : START2 :
; 29   : 		xor ecx, ecx

  00040	33 c9		 xor	 ecx, ecx

; 30   : 		
; 31   : 			mov edi, data

  00042	8b 7d 08	 mov	 edi, DWORD PTR _data$[ebp]
$START$4:

; 32   : 
; 33   : 
; 34   : START :
; 35   : 		cmp ecx, dataLength

  00045	3b 4d 0c	 cmp	 ecx, DWORD PTR _dataLength$[ebp]

; 36   : 		jge DONE

  00048	0f 8d aa 00 00
	00		 jge	 $DONE$5
$E$6:

; 37   : 		
; 38   : 
; 39   : E://code table swap
; 40   : 		
; 41   : 		
; 42   : 		
; 43   : 			movzx eax, byte ptr[edi + ecx]

  0004e	0f b6 04 0f	 movzx	 eax, BYTE PTR [edi+ecx]

; 44   : 			lea esi, gDecodeTable//gets first value of the table

  00052	8d 35 00 00 00
	00		 lea	 esi, OFFSET ?gDecodeTable@@3PAEA

; 45   : 			movzx al, [esi + eax]

  00058	66 0f b6 04 06	 movzx	 ax, BYTE PTR [esi+eax]

; 46   : 			mov byte ptr[edi + ecx], al//swap data with the new bit from decryption table 

  0005d	88 04 0f	 mov	 BYTE PTR [edi+ecx], al
$B$7:

; 47   : 			
; 48   : 			
; 49   : 
; 50   : 			
; 51   : B:   //swapping nibbles
; 52   : 			xor edx, edx

  00060	33 d2		 xor	 edx, edx

; 53   : 			xor ebx, ebx

  00062	33 db		 xor	 ebx, ebx

; 54   : 			movzx eax, byte ptr[edi + ecx]

  00064	0f b6 04 0f	 movzx	 eax, BYTE PTR [edi+ecx]

; 55   : 			mov dl, al

  00068	8a d0		 mov	 dl, al

; 56   : 			mov bl, al

  0006a	8a d8		 mov	 bl, al

; 57   : 
; 58   : 
; 59   : 
; 60   : 			and dl, 0xf0  //preserving one of the bits 

  0006c	80 e2 f0	 and	 dl, -16			; fffffff0H

; 61   : 			ror dl, 4//rotating the bit to the right 4 times 

  0006f	c0 ca 04	 ror	 dl, 4

; 62   : 
; 63   : 
; 64   : 			and bl, 0x0f//preserving the opposite bit

  00072	80 e3 0f	 and	 bl, 15			; 0000000fH

; 65   : 			ror bl, 4//rotating it again 4 times 

  00075	c0 cb 04	 ror	 bl, 4

; 66   : 
; 67   : 
; 68   : 			xor eax, eax

  00078	33 c0		 xor	 eax, eax

; 69   : 			add eax, ebx

  0007a	03 c3		 add	 eax, ebx

; 70   : 			add eax, edx

  0007c	03 c2		 add	 eax, edx

; 71   : 			mov byte ptr[edi + ecx], al

  0007e	88 04 0f	 mov	 BYTE PTR [edi+ecx], al
$C$8:

; 72   : 
; 73   : 
; 74   : 			
; 75   : 
; 76   : 
; 77   : C:
; 78   : 			//reversing the bit order
; 79   : 				movzx eax, byte ptr[edi + ecx]

  00081	0f b6 04 0f	 movzx	 eax, BYTE PTR [edi+ecx]

; 80   : 				xor ebx, ebx

  00085	33 db		 xor	 ebx, ebx

; 81   : 				xor edx, edx

  00087	33 d2		 xor	 edx, edx

; 82   : 				//counter to move all the bits 
; 83   : 				mov edx, 7

  00089	ba 07 00 00 00	 mov	 edx, 7
$LOOP1$9:

; 84   : 				//loop to rotate all bits until the order is reversed
; 85   : LOOP1:
; 86   : 				sar al, 1

  0008e	d0 f8		 sar	 al, 1

; 87   : 				rcl bl, 1 //rotating a bit through the carry 

  00090	d0 d3		 rcl	 bl, 1

; 88   : 				test edx, edx

  00092	85 d2		 test	 edx, edx

; 89   : 				je CDONE

  00094	74 03		 je	 SHORT $CDONE$10

; 90   : 				dec edx

  00096	4a		 dec	 edx

; 91   : 				jmp LOOP1

  00097	eb f5		 jmp	 SHORT $LOOP1$9
$CDONE$10:

; 92   : 
; 93   : CDONE :
; 94   : 				mov al, bl

  00099	8a c3		 mov	 al, bl

; 95   : 				mov byte ptr[edi + ecx], al

  0009b	88 04 0f	 mov	 BYTE PTR [edi+ecx], al
$A$11:

; 96   : 
; 97   : 
; 98   : 
; 99   : 				
; 100  : 
; 101  : 
; 102  : 
; 103  : A:
; 104  : 		movzx eax, byte ptr[edi + ecx]

  0009e	0f b6 04 0f	 movzx	 eax, BYTE PTR [edi+ecx]

; 105  : 		ror al, 1  //rotating the bit to to the right 

  000a2	d0 c8		 ror	 al, 1

; 106  : 		mov byte ptr[edi + ecx], al

  000a4	88 04 0f	 mov	 BYTE PTR [edi+ecx], al
$D$12:

; 107  : 
; 108  : 
; 109  : 
; 110  : 
; 111  : 
; 112  : 		
; 113  : 
; 114  : D:
; 115  : 		//rotating high nibble right and low nibble left
; 116  : 			xor edx, edx

  000a7	33 d2		 xor	 edx, edx

; 117  : 			xor ebx, ebx

  000a9	33 db		 xor	 ebx, ebx

; 118  : 			movzx eax, byte ptr[edi + ecx]

  000ab	0f b6 04 0f	 movzx	 eax, BYTE PTR [edi+ecx]

; 119  : 			mov dl, al//gets one byte of the data

  000af	8a d0		 mov	 dl, al

; 120  : 
; 121  : 
; 122  : 			and dl, 0xf0

  000b1	80 e2 f0	 and	 dl, -16			; fffffff0H

; 123  : 			ror dl, 1 //rotating the high nibble right

  000b4	d0 ca		 ror	 dl, 1

; 124  : 			clc

  000b6	f8		 clc

; 125  : 			bt dl, 3

  000b7	66 0f ba e2 03	 bt	 dx, 3

; 126  : 			jc RH

  000bc	72 11		 jb	 SHORT $RH$13
$RO1$14:

; 127  : RO1 :
; 128  : 
; 129  : 			mov bl, al

  000be	8a d8		 mov	 bl, al

; 130  : 			and bl, 0x0f

  000c0	80 e3 0f	 and	 bl, 15			; 0000000fH

; 131  : 			rol bl, 1  //rotaing low nibble left

  000c3	d0 c3		 rol	 bl, 1

; 132  : 			clc

  000c5	f8		 clc

; 133  : 			bt bl, 4

  000c6	66 0f ba e3 04	 bt	 bx, 4

; 134  : 			jc RL

  000cb	72 0a		 jb	 SHORT $RL$15

; 135  : 			jmp DDONE

  000cd	eb 10		 jmp	 SHORT $DDONE$16
$RH$13:

; 136  : 
; 137  : 
; 138  : RH :  //checking to see if there was an end bit that was rotated out 
; 139  : 			and dl, 0xf0

  000cf	80 e2 f0	 and	 dl, -16			; fffffff0H

; 140  : 			or dl, 0x80

  000d2	80 ca 80	 or	 dl, -128		; ffffff80H

; 141  : 			jmp RO1

  000d5	eb e7		 jmp	 SHORT $RO1$14
$RL$15:

; 142  : 
; 143  : RL :
; 144  : 			//also checking for end bit but on opposite side 
; 145  : 			and bl, 0x0f

  000d7	80 e3 0f	 and	 bl, 15			; 0000000fH

; 146  : 			or bl, 0x01

  000da	80 cb 01	 or	 bl, 1

; 147  : 			jmp DDONE

  000dd	eb 00		 jmp	 SHORT $DDONE$16
$DDONE$16:

; 148  : 
; 149  : DDONE :
; 150  : 
; 151  : 			xor eax, eax

  000df	33 c0		 xor	 eax, eax

; 152  : 			add eax, edx

  000e1	03 c2		 add	 eax, edx

; 153  : 			add eax, ebx

  000e3	03 c3		 add	 eax, ebx

; 154  : 			mov byte ptr[edi + ecx], al

  000e5	88 04 0f	 mov	 BYTE PTR [edi+ecx], al

; 155  : 			
; 156  : 
; 157  : 
; 158  : 
; 159  : 			
; 160  : 
; 161  : 
; 162  : 			inc ecx

  000e8	41		 inc	 ecx

; 163  : 			jmp START

  000e9	e9 57 ff ff ff	 jmp	 $START$4
$NEWHOP$17:

; 164  : 		
; 165  : 		
; 166  : NEWHOP:
; 167  : 	
; 168  : 			mov eax, 0xffff

  000ee	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 169  : 			mov resulti, eax

  000f3	89 45 f8	 mov	 DWORD PTR _resulti$[ebp], eax

; 170  : 			jmp CN

  000f6	eb 3e		 jmp	 SHORT $CN$18
$DONE$5:

; 171  : 
; 172  : 
; 173  : DONE:  //
; 174  : 				xor ecx, ecx

  000f8	33 c9		 xor	 ecx, ecx

; 175  : 				mov ecx,gNumRounds

  000fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gNumRounds@@3HA ; gNumRounds

; 176  : 				mov ebx, dataLength

  00100	8b 5d 0c	 mov	 ebx, DWORD PTR _dataLength$[ebp]

; 177  : 				lea edi, gkey

  00103	8d 3d 00 00 00
	00		 lea	 edi, OFFSET ?gkey@@3PAEA

; 178  : 				mov edi, gptrKey

  00109	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gptrKey@@3PAEA ; gptrKey

; 179  : 				lea esi, gPasswordHash

  0010f	8d 35 00 00 00
	00		 lea	 esi, OFFSET ?gPasswordHash@@3PAEA

; 180  : 				mov esi, gptrPasswordHash

  00115	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gptrPasswordHash@@3PAEA ; gptrPasswordHash

; 181  : 
; 182  : 
; 183  : 
; 184  : 				mov edx, data   //gets data

  0011b	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]

; 185  : 				mov ebx, edx //moves data into ebx

  0011e	8b da		 mov	 ebx, edx

; 186  : 				add ebx, dataLength

  00120	03 5d 0c	 add	 ebx, DWORD PTR _dataLength$[ebp]

; 187  : 				//setting up the hop count
; 188  : 				xor eax, eax

  00123	33 c0		 xor	 eax, eax

; 189  : 				mov ah, byte ptr[esi + 2 + ecx * 4]

  00125	8a 64 8e 02	 mov	 ah, BYTE PTR [esi+ecx*4+2]

; 190  : 				mov al, byte ptr[esi + 3 + ecx * 4]

  00129	8a 44 8e 03	 mov	 al, BYTE PTR [esi+ecx*4+3]

; 191  : 				cmp ax, 0

  0012d	66 83 f8 00	 cmp	 ax, 0

; 192  : 				je NEWHOP

  00131	74 bb		 je	 SHORT $NEWHOP$17

; 193  : 				mov resulti, eax

  00133	89 45 f8	 mov	 DWORD PTR _resulti$[ebp], eax
$CN$18:

; 194  : 
; 195  : CN://getting the index
; 196  : 
; 197  : 			xor eax, eax

  00136	33 c0		 xor	 eax, eax

; 198  : 				mov ah, byte ptr[esi + ecx*4]

  00138	8a 24 8e	 mov	 ah, BYTE PTR [esi+ecx*4]

; 199  : 				mov al, byte ptr[esi + ecx*4 + 1]

  0013b	8a 44 8e 01	 mov	 al, BYTE PTR [esi+ecx*4+1]
$NEXT$19:

; 200  : 
; 201  : 
; 202  : 
; 203  : NEXT : //Encyrpting the data with the hash
; 204  : 				xor ecx, ecx

  0013f	33 c9		 xor	 ecx, ecx

; 205  : 				mov cl, byte ptr[edx]

  00141	8a 0a		 mov	 cl, BYTE PTR [edx]

; 206  : 				xor cl, byte ptr[edi + eax]

  00143	32 0c 07	 xor	 cl, BYTE PTR [edi+eax]

; 207  : 				mov byte ptr[edx], cl

  00146	88 0a		 mov	 BYTE PTR [edx], cl

; 208  : 
; 209  : 				inc edx

  00148	42		 inc	 edx

; 210  : 				cmp edx, ebx   //checks to see if we're done encrypting data

  00149	3b d3		 cmp	 edx, ebx

; 211  : 				je NOWDONE

  0014b	74 11		 je	 SHORT $NOWDONE$20

; 212  : 
; 213  : 				add eax, resulti  //update by the hop count

  0014d	03 45 f8	 add	 eax, DWORD PTR _resulti$[ebp]

; 214  : 				cmp eax, 65537  //check boundary conditions

  00150	3d 01 00 01 00	 cmp	 eax, 65537		; 00010001H

; 215  : 				jb NEXT//repeat until done 

  00155	72 e8		 jb	 SHORT $NEXT$19

; 216  : 				sub eax, 65537

  00157	2d 01 00 01 00	 sub	 eax, 65537		; 00010001H

; 217  : 				jmp NEXT

  0015c	eb e1		 jmp	 SHORT $NEXT$19
$NOWDONE$20:

; 218  : 
; 219  : NOWDONE :  //checking the number of rounds thats left to determine continuation 
; 220  : 			mov ecx, gNumRounds

  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gNumRounds@@3HA ; gNumRounds

; 221  : 				dec ecx

  00164	49		 dec	 ecx

; 222  : 				mov gNumRounds, ecx

  00165	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gNumRounds@@3HA, ecx ; gNumRounds

; 223  : 				cmp ecx, -1

  0016b	83 f9 ff	 cmp	 ecx, -1

; 224  : 				jne START2

  0016e	0f 85 cc fe ff
	ff		 jne	 $START2$3

; 225  : 				mov resulti, 0

  00174	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _resulti$[ebp], 0

; 226  : 	}
; 227  : 
; 228  : 	
; 229  : 
; 230  : 	return resulti;

  0017b	8b 45 f8	 mov	 eax, DWORD PTR _resulti$[ebp]

; 231  : } // decryptData

  0017e	5f		 pop	 edi
  0017f	5e		 pop	 esi
  00180	5b		 pop	 ebx
  00181	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00187	3b ec		 cmp	 ebp, esp
  00189	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
?decryptData@@YAHPADH@Z ENDP				; decryptData
_TEXT	ENDS
END
